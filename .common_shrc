# Add my custom scripts to the PATH
my_script_path="${HOME}/dev/dotfiles/scripts"
add_to_path "${my_script_path}"

##########################################
# Mapping `oh-my-zsh` enabled plugin aliases to bash
##########################################
${my_script_path}/generate_bash_aliases.sh
# Add to your .bashrc
if [ -f ~/.bash_aliases_from_zsh ]; then
    # Try to source it with error handling
    {
        source ~/.bash_aliases_from_zsh
    } 2>/dev/null || {
        echo "Warning: Some aliases from zsh couldn't be loaded due to compatibility issues."
    }
fi

##########################################
# Custom Functions
##########################################

# makedir and cd
mkcd() {
    mkdir -pv "$1" && cd "$1"
}


dun() { 
    du -h --max-depth="${1:-1}" | sort -h --reverse
} 

# Function to safely add to PATH
add_to_path() {
    # Check if directory exists and path is not already in PATH
    if [[ -d "$1" ]] && [[ ":$PATH:" != *":$1:"* ]]; then
        export PATH="$1:$PATH"
        echo "Added $1 to PATH"
    #elif [[ ":$PATH:" == *":$1:"* ]]; then
        #echo "$1 already in PATH"
    #else
        #echo "Directory $1 does not exist"
    fi
}

# Markdown link check in a folder, recursive
function mlc() {
  find $1 -name \*.md -exec markdown-link-check -p {} \;
}

# rapid/intelligent search for files/directories
s() {
  fzf --ansi --disabled \
    --bind "change:reload:command \
          rg --line-number --no-heading --color=always --smart-case {q} \
          || :" \
    --bind "enter:execute(${EDITOR:-nvim} +{2} {1})" \
    --delimiter ":" \
    --preview "command batcat -p --color=always {1} --highlight-line {2}" \
    --preview-window 'up:80%,border-bottom,~3,+{2}+3/3'
}

# get process IDs running on all GPUs
get_gpu_procs () {
   for gpu_id in $(nvidia-smi --list-gpus | awk '{print $2}' | tr -d ':'); do
      gpu_name=$(nvidia-smi --query-gpu=gpu_name --format=csv,noheader,nounits --id=$gpu_id)
      pids=$(nvidia-smi --query-compute-apps=pid --format=csv,noheader --id=$gpu_id)
      if [ -n "$pids" ]; then
          echo "GPU $gpu_id ($gpu_name):"
          echo "$pids" | xargs --no-run-if-empty ps -o user,pid,command
          echo ""
      fi
   done
}

#----------------------------------------
# Start of Config
#----------------------------------------

# Make nvim the default text editor
export EDITOR=nvim
export VISUAL=nvim

#export LANGUAGE=(unset),                                                                                                                       â”‚
export LC_ALL=en_US.UTF-8
export LC_COLLATE=en_US
export LANG=en_US.UTF-8

#######################################
# Aliases
#######################################

#alias dirs="dirs -p"
#alias fd="fdfind"
#alias firewood='for remote in `git branch -r`; do git branch --track ${remote#origin/} $remote; done'
#alias ov=/opt/ov/omniverse-launcher-linux.AppImage
alias active-users="ps -eo user | sort | uniq | grep -Ev \"USER|avahi|colord|gdm|kernoops|lp|messagebus|root|rtkit|syslog|systemd|whoopsie|xrdp|_rpc|daemon\""
alias bat="batcat --color=always"
#alias cp='cp -Rv'
alias dff="df --total -h | grep -v snap | grep -v tmpfs"
alias dirs="dirs -p"
alias docker-root="DOCKER_HOST=unix:///var/run/docker.sock docker"
alias docker-rootless="DOCKER_HOST=unix:///run/user/10227/docker.sock docker"
alias docps="docker ps --format \"table {{.Names}}\" | grep -v NAMES"
alias du1="du -hx --max-depth=1 | sort -h --reverse"
#alias eza="eza --icons"
alias gsui='git submodule update --init'
alias gsuir='git submodule update --init --recursive'
alias gant=ganttproject
alias glow="glow -p"
#alias grep='grep --color=auto'
alias grepw='grep --color=auto -Hrnwi'
alias h='history'
#alias l='ls -CF'
#alias la='ls -AF'
#alias ll='ls -alhF --color'
#alias ls='ls --color=auto -aCF'
alias lzd="lazydocker"
alias lzg="lazygit"
alias lzv="nvim"
#alias mkdir='mkdir -pv'
alias mv='mv -v' #(overriding 'oh-my-zsh')
alias nv='nvim'
alias pdf="xdg-open" #"gio open", or "evince"
alias tree="tree -aI 'test*|.git|node_modules|resources'"
alias turbo="/opt/TurboVNC/bin/vncserver -localhost"
alias wget='wget -c'
alias wsl-vpnkit="sudo VMEXEC_PATH=${HOME}/apps/wsl-vpnkit/wsl-vm GVPROXY_PATH=${HOME}/apps/wsl-vpnkit/wsl-gvproxy.exe ${HOME}/apps/wsl-vpnkit/wsl-vpnkit"
alias wt="wezterm"
if [ ! -z ${TERMUX_VERSION} ]; then
  alias rm="trash" #(overriding 'oh-my-zsh')
fi

#######################################
# Git Completion Support
#######################################

if [ -f ~/.git-completion.bash ]; then
  . ~/.git-completion.bash

  # Add git completion to aliases
  __git_complete goto _git_checkout
fi


#######################################
# Exports
#######################################

# Needed for rootless docker
#export DOCKER_HOST=unix:///run/user/10227/docker.sock
export DOCKER_HOST="unix:///run/user/$(id -u)/docker.sock"
export INFOPATH="/usr/local/texlive/texmf-dist/doc/info:${INFOPATH}"
export JAVA_HOME="/usr/local/openjdk-17"
export LD_LIBRARY_PATH="/usr/local/cuda-12.4/lib64:${LD_LIBRARY_PATH}"
export MANPATH="/usr/local/texlive/texmf-dist/doc/man:${MANPATH}"
export XDG_RUNTIME_DIR="/run/user/$(id -u)"

# Use it for all your paths
add_to_path "/opt/nvim-linux64/bin"
add_to_path "/opt/nvim-linux-x86_64/bin"
add_to_path "${HOME}/.local/kitty.app/bin"
add_to_path "${HOME}/apps/lua-5.4.7/bin"
add_to_path "${HOME}/apps/luarocks-3.11.1/bin"
add_to_path "${HOME}/dev/dotfiles/scripts/programs/lua-5.4.7/bin"
add_to_path "${JAVA_HOME}/bin"
add_to_path "/usr/local/cuda-12.4/bin"
add_to_path "/usr/local/texlive/bin/x86_64-linux"
#add_to_path "${HOME}/.local/kitty.app/bin"


##########################################
# RUST Support
##########################################
if [[ -f "${HOME}/.cargo/env" ]]; then
    source "${HOME}/.cargo/env"
fi

##########################################
# PYENV Support
##########################################

if [ -z ${TERMUX_VERSION} ]; then
  #[[ -f init.conda ]] && source init.conda
  [[ -f init.pyenv ]] && source init.pyenv
fi

##########################################
# NVM Support
##########################################
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion


##########################################
# End of file...
##########################################
