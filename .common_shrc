##########################################
# Custom Functions
##########################################

# makedir and cd
mkcd() {
    mkdir -pv "$1" && cd "$1"
}


dun() { 
    du -h --max-depth="${1:-1}" | sort -h --reverse
} 

# Function to safely add to PATH
add_to_path() {
    # Check if directory exists and path is not already in PATH
    if [[ -d "$1" ]] && [[ ":$PATH:" != *":$1:"* ]]; then
        export PATH="$1:$PATH"
        echo "Added $1 to PATH"
    #elif [[ ":$PATH:" == *":$1:"* ]]; then
        #echo "$1 already in PATH"
    #else
        #echo "Directory $1 does not exist"
    fi
}

# Markdown link check in a folder, recursive
function mlc() {
  find $1 -name \*.md -exec markdown-link-check -p {} \;
}

# rapid/intelligent search for files/directories
s() {
  fzf --ansi --disabled \
    --bind "change:reload:command \
          rg --line-number --no-heading --color=always --smart-case {q} \
          || :" \
    --bind "enter:execute(${EDITOR:-nvim} +{2} {1})" \
    --delimiter ":" \
    --preview "command batcat -p --color=always {1} --highlight-line {2}" \
    --preview-window 'up:80%,border-bottom,~3,+{2}+3/3'
}

# get process IDs running on all GPUs
get_gpu_procs () {
   for gpu_id in $(nvidia-smi --list-gpus | awk '{print $2}' | tr -d ':'); do
      gpu_name=$(nvidia-smi --query-gpu=gpu_name --format=csv,noheader,nounits --id=$gpu_id)
      pids=$(nvidia-smi --query-compute-apps=pid --format=csv,noheader --id=$gpu_id)
      if [ -n "$pids" ]; then
          echo "GPU $gpu_id ($gpu_name):"
          echo "$pids" | xargs --no-run-if-empty ps -o user,pid,command
          echo ""
      fi
   done
}

# Add my custom scripts to the PATH
my_script_path="${HOME}/dev/dotfiles/scripts"
add_to_path "${my_script_path}"


#----------------------------------------
# Start of Config
#----------------------------------------

# Make nvim the default text editor
export EDITOR=nvim
export VISUAL=nvim

#export LANGUAGE=(unset),                                                                                                                       â”‚
export LC_ALL=en_US.UTF-8
export LC_COLLATE=en_US
export LANG=en_US.UTF-8

#######################################
# Aliases
#######################################

#alias dirs="dirs -p"
#alias fd="fdfind"
#alias firewood='for remote in `git branch -r`; do git branch --track ${remote#origin/} $remote; done'
#alias ov=/opt/ov/omniverse-launcher-linux.AppImage
alias active-users="ps -eo user | sort | uniq | grep -Ev \"USER|avahi|colord|gdm|kernoops|lp|messagebus|root|rtkit|syslog|systemd|whoopsie|xrdp|_rpc|daemon\""
alias bat="batcat --color=always"
alias cp='cp -Rv'
alias dff="df --total -h | grep -v snap | grep -v tmpfs"
alias dirs="dirs -p"
alias docker-root="DOCKER_HOST=unix:///var/run/docker.sock docker"
alias docker-rootless="DOCKER_HOST=unix:///run/user/10227/docker.sock docker"
alias docps="docker ps --format \"table {{.Names}}\" | grep -v NAMES"
alias du1="du -hx --max-depth=1 | sort -h --reverse"
alias eza="eza --icons"
alias forgotsubmodules='git submodule update --init --recursive'
alias gant=ganttproject
alias glow="glow -p"
alias grep='grep --color=auto'
alias grepw='grep --color=auto -Hrnwi'
alias h='history'
alias l='ls -CF'
alias la='ls -AF'
alias ll='ls -alhF --color'
alias ls='ls --color=auto -aCF'
alias lzd="lazydocker"
alias lzg="lazygit"
alias lzv="nvim"
alias mkdir='mkdir -pv'
alias mv='mv -v'
alias nv='nvim'
alias pdf="xdg-open" #"gio open", or "evince"
alias tree="tree -aI 'test*|.git|node_modules|resources'"
alias turbo="/opt/TurboVNC/bin/vncserver -localhost"
alias wget='wget -c'
alias wsl-vpnkit="sudo VMEXEC_PATH=${HOME}/apps/wsl-vpnkit/wsl-vm GVPROXY_PATH=${HOME}/apps/wsl-vpnkit/wsl-gvproxy.exe ${HOME}/apps/wsl-vpnkit/wsl-vpnkit"
alias wt="wezterm"
if [ ! -z ${TERMUX_VERSION} ]; then
  alias rm="trash"
fi

## enable color support of ls and also add handy aliases
#if [ -x /usr/bin/dircolors ]; then
#    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
#    alias ls='ls --color=auto'
#    #alias dir='dir --color=auto'
#    #alias vdir='vdir --color=auto'
#
#    alias grep='grep --color=auto'
#    alias fgrep='fgrep --color=auto'
#    alias egrep='egrep --color=auto'
#fi

#########

#alias branches='git branch -v'
#alias checkgit='~/.git-rundown.sh'
#alias remotes='git remote -v'
#alias gadd='git add -u'
#alias gcom='git commit'
#alias gsup='git status'
#alias goto='git checkout'
#alias g.a='git add -u'
#alias g.c='git commit'
#alias g.s='git status'
#alias g.co='git checkout'
#alias g.b='git branch -v'
#alias g.ps='git push'
#alias g.pd='git pull'
#alias g.r='git remote -v'
#alias g.subup='git submodule update --init --recursive'
#alias g.lo="git log --oneline --format=\"%h %as [%an] -- %s\""
#  a      = commit --amend
#  br     = branch -av
#  ca     = !git add -A && git commit                # Commit all changes.
#  ci     = commit
#  co     = checkout
#  cp     = cherry-pick
#  d      = diff
#  dc     = diff --cached
#  df     = diff --word-diff
#  g      = log --graph --pretty=custom              # Show custom graph.
#  l      = log --pretty=custom                      # Show custom log.
#  ls     = log --pretty=custom                      # Show custom log.
#  lc     = shortlog --summary --numbered            # List contributors.
#  ll     = log --pretty=custom --decorate --numstat
#  p      = push
#  r      = rebase
#  rlc    = reset --hard HEAD~1                      # Remove last commit.
#  sa     = stash apply
#  sc     = stash clear
#  sd     = stash drop
#  sl     = stash list
#  sp     = stash pop
#  ss     = stash save
#  sw     = stash show
#  st     = status
#  tags   = tag -l
#  ulc    = reset --soft HEAD~1                      # Undo last commit.
#  un     = reset HEAD --
#  up     = pull upstream master
#  screwit = !git reset --hard HEAD && git clean -df


#######################################
# Git Completion Support
#######################################

if [ -f ~/.git-completion.bash ]; then
  . ~/.git-completion.bash

  # Add git completion to aliases
  __git_complete goto _git_checkout
fi


#######################################
# Exports
#######################################

# Needed for rootless docker
#export DOCKER_HOST=unix:///run/user/10227/docker.sock
export DOCKER_HOST="unix:///run/user/$(id -u)/docker.sock"
export INFOPATH="/usr/local/texlive/texmf-dist/doc/info:${INFOPATH}"
export JAVA_HOME="/usr/local/openjdk-17"
export LD_LIBRARY_PATH="/usr/local/cuda-12.4/lib64:${LD_LIBRARY_PATH}"
export MANPATH="/usr/local/texlive/texmf-dist/doc/man:${MANPATH}"
export XDG_RUNTIME_DIR="/run/user/$(id -u)"

# Use it for all your paths
add_to_path "/opt/nvim-linux64/bin"
add_to_path "/opt/nvim-linux-x86_64/bin"
add_to_path "${HOME}/.local/kitty.app/bin"
add_to_path "${HOME}/apps/lua-5.4.7/bin"
add_to_path "${HOME}/apps/luarocks-3.11.1/bin"
add_to_path "${HOME}/dev/dotfiles/scripts/programs/lua-5.4.7/bin"
add_to_path "${JAVA_HOME}/bin"
add_to_path "/usr/local/cuda-12.4/bin"
add_to_path "/usr/local/texlive/bin/x86_64-linux"
#add_to_path "${HOME}/.local/kitty.app/bin"


##########################################
# RUST Support
##########################################
if [[ -f "${HOME}/.cargo/env" ]]; then
    source "${HOME}/.cargo/env"
fi

##########################################
# PYENV Support
##########################################

if [ -z ${TERMUX_VERSION} ]; then
  #[[ -f init.conda ]] && source init.conda
  [[ -f init.pyenv ]] && source init.pyenv
fi

##########################################
# NVM Support
##########################################
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion


##########################################
# End of file...
##########################################
